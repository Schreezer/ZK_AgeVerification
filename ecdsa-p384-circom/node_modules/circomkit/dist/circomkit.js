"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Circomkit = void 0;
const snarkjs = __importStar(require("snarkjs"));
const wasm_tester = require('circom_tester').wasm;
const fs_1 = require("fs");
const promises_1 = require("fs/promises");
const crypto_1 = require("crypto");
const loglevel_1 = require("loglevel");
const child_process_1 = require("child_process");
const utils_1 = require("./utils/");
const ptau_1 = require("./utils/ptau");
const testers_1 = require("./testers/");
const utils_2 = require("./utils");
const config_1 = require("./utils/config");
/**
 * Circomkit is an opinionated wrapper around many SnarkJS functions.
 *
 * It abstracts away all the path and commands by providing a simple interface,
 * built around just providing the circuit name and the input name.
 *
 * ```ts
 * const circomkit = new Circomkit()
 * ```
 *
 * It also provides a **WitnessTester** and a **ProofTester** module which use Chai assertions within.
 *
 * ```ts
 * const witnessTester = await circomkit.WitnessTester(circuitName, circuitConfig)
 * const proofTester = await circomkit.ProofTester(circuitName)
 * ```
 */
class Circomkit {
    constructor(overrides = {}) {
        // override default options with the user-provided ones
        // we can do this via two simple spreads because both objects are single depth
        const config = {
            ...config_1.defaultConfig,
            ...overrides,
        };
        this.config = JSON.parse(JSON.stringify(config));
        this.logger = (0, loglevel_1.getLogger)('Circomkit');
        this.logger.setLevel(this.config.logLevel);
        // logger for SnarkJS, accepted as an optional argument within their functions
        this.snarkjsLogger = this.config.verbose ? this.logger : undefined;
        // sanity checks
        if (!config_1.CURVES.includes(this.config.prime)) {
            throw new Error('Invalid prime in configuration.');
        }
        if (!config_1.PROTOCOLS.includes(this.config.protocol)) {
            throw new Error('Invalid protocol in configuration.');
        }
        if (this.config.optimization < 0) {
            this.config.optimization = 0;
        }
    }
    /** Parse circuit config from `circuits.json`. */
    readCircuitConfig(circuit) {
        const circuits = JSON.parse((0, fs_1.readFileSync)(this.config.circuits, 'utf-8'));
        if (!(circuit in circuits)) {
            throw new Error('No such circuit in ' + this.config.circuits);
        }
        return circuits[circuit];
    }
    /** Computes a path that requires a circuit name. */
    path(circuit, type) {
        const dir = `${this.config.dirBuild}/${circuit}`;
        switch (type) {
            case 'dir':
                return dir;
            case 'main':
                return `${this.config.dirCircuits}/main/${circuit}.circom`;
            case 'r1cs':
                return `${dir}/${circuit}.r1cs`;
            case 'sym':
                return `${dir}/${circuit}.sym`;
            case 'wasm':
                return `${dir}/${circuit}_js/${circuit}.wasm`;
            case 'pkey':
                return `${dir}/${this.config.protocol}_pkey.zkey`;
            case 'vkey':
                return `${dir}/${this.config.protocol}_vkey.json`;
            case 'sol':
                return `${dir}/${this.config.protocol}_verifier.sol`;
            default:
                throw new Error('Invalid type: ' + type);
        }
    }
    /** Computes a path that requires a circuit and an input name. */
    pathWithInput(circuit, input, type) {
        const dir = `${this.config.dirBuild}/${circuit}/${input}`;
        switch (type) {
            case 'dir':
                return dir;
            case 'pubs':
                return `${dir}/public.json`;
            case 'proof':
                return `${dir}/proof.json`;
            case 'wtns':
                return `${dir}/witness.wtns`;
            case 'in':
                return `${this.config.dirInputs}/${circuit}/${input}.json`;
            default:
                throw new Error('Invalid type: ' + type);
        }
    }
    /** Given a PTAU name, returns the relative path. */
    pathPtau(ptauName) {
        return `${this.config.dirPtau}/${ptauName}`;
    }
    /** Given a circuit & id name, returns the relative path of the phase-2 PTAU.
     * This is used in particular by Groth16's circuit-specific setup phase. */
    pathZkey(circuit, id) {
        return `${this.config.dirBuild}/${circuit}/${circuit}_${id}.zkey`;
    }
    /** Colorful logging using the internal logger */
    log(message, type = 'info') {
        // TODO: this is very smelly code, find a better way
        if (type === 'title' || type === 'success') {
            this.logger.info(`${config_1.colors[type]}${message}\x1b[0m`);
        }
        else {
            this.logger[type](`${config_1.colors[type]}${message}\x1b[0m`);
        }
    }
    /** Clean build files and the `main` component of a circuit. */
    async clean(circuit) {
        await Promise.all([
            (0, promises_1.rm)(this.path(circuit, 'dir'), { recursive: true, force: true }),
            (0, promises_1.rm)(this.path(circuit, 'main'), { force: true }),
        ]);
    }
    /** Export a verification key (vKey) from a proving key (zKey). */
    async vkey(circuit, pkeyPath) {
        const vkeyPath = this.path(circuit, 'vkey');
        // check if it exists
        if (pkeyPath === undefined) {
            pkeyPath = this.path(circuit, 'pkey');
        }
        if (!(0, fs_1.existsSync)(pkeyPath)) {
            throw new Error('There must be a prover key for this circuit to extract a verification key.');
        }
        // extract it
        const vkey = await snarkjs.zKey.exportVerificationKey(pkeyPath, this.snarkjsLogger);
        (0, fs_1.writeFileSync)(vkeyPath, (0, utils_2.prettyStringify)(vkey));
        return vkeyPath;
    }
    /** Information about circuit. */
    async info(circuit) {
        // we do not pass `this.snarkjsLogger` here on purpose
        const r1csinfo = await snarkjs.r1cs.info(this.path(circuit, 'r1cs'), undefined);
        return {
            variables: r1csinfo.nVars,
            constraints: r1csinfo.nConstraints,
            privateInputs: r1csinfo.nPrvInputs,
            publicInputs: r1csinfo.nPubInputs,
            useCustomGates: r1csinfo.useCustomGates,
            labels: r1csinfo.nLabels,
            outputs: r1csinfo.nOutputs,
            prime: r1csinfo.prime,
            primeName: utils_2.primeToName[r1csinfo.prime.toString(10)],
        };
    }
    /** Downloads the phase-1 setup PTAU file for a circuit based on it's number of constraints.
     *
     * The downloaded PTAU files can be seen at [SnarkJS docs](https://github.com/iden3/snarkjs#7-prepare-phase-2).
     * Note that this may take a while if the circuit is large and thus a larger PTAU is needed.
     *
     * This function only works when the used prime is `bn128`.
     *
     * @returns path of the downloaded PTAU file
     */
    async ptau(circuit) {
        if (this.config.prime !== 'bn128') {
            throw new Error('Auto-downloading PTAU only allowed for bn128 at the moment.');
        }
        // @todo check for performance gains when larger PTAUs are found instead of the target PTAU
        const { constraints } = await this.info(circuit);
        const ptauName = (0, ptau_1.getPtauName)(constraints);
        // return if ptau exists already
        const ptauPath = this.pathPtau(ptauName);
        if ((0, fs_1.existsSync)(ptauPath)) {
            return ptauPath;
        }
        else {
            (0, fs_1.mkdirSync)(this.config.dirPtau, { recursive: true });
            this.log('Downloading ' + ptauName + '...');
            return await (0, ptau_1.downloadPtau)(ptauName, this.config.dirPtau);
        }
    }
    /** Compile the circuit.
     *
     * A circuit configuration can be passed optionally; if not, the
     * config will be read from `circuits.json` at the working directory.
     *
     * @returns path of the build directory
     */
    async compile(circuit, config) {
        const targetPath = this.instantiate(circuit, config);
        this.log('Main component created at: ' + targetPath, 'debug');
        const outDir = this.path(circuit, 'dir');
        (0, fs_1.mkdirSync)(outDir, { recursive: true });
        // prettier-ignore
        let flags = `--sym --wasm --r1cs -p ${this.config.prime} -o ${outDir}`;
        if (this.config.include.length > 0)
            flags += ' ' + this.config.include.map(path => `-l ${path}`).join(' ');
        if (this.config.verbose)
            flags += ' --verbose';
        if (this.config.inspect)
            flags += ' --inspect';
        if (this.config.cWitness)
            flags += ' --c';
        if (this.config.optimization > 2) {
            // --O2round <value>
            flags += ` --O2round ${this.config.optimization}`;
        }
        else {
            // --O0, --O1 or --O2
            flags += ` --O${this.config.optimization}`;
        }
        // call `circom` as a sub-process
        try {
            const result = await new Promise((resolve, reject) => {
                (0, child_process_1.exec)(`circom ${flags} ${targetPath}`, (error, stdout, stderr) => {
                    if (error === null) {
                        resolve({ stdout, stderr });
                    }
                    else {
                        reject(error);
                    }
                });
            });
            if (this.config.verbose) {
                this.log(result.stdout);
            }
            if (result.stderr) {
                this.log(result.stderr, 'error');
            }
        }
        catch (e) {
            throw new Error('Compiler error:\n' + e);
        }
        return outDir;
    }
    /** Exports a solidity contract for the verifier.
     * @returns path of the exported Solidity contract
     */
    async contract(circuit) {
        const pkey = this.path(circuit, 'pkey');
        const template = (0, fs_1.readFileSync)(`./node_modules/snarkjs/templates/verifier_${this.config.protocol}.sol.ejs`, 'utf-8');
        const contractCode = await snarkjs.zKey.exportSolidityVerifier(pkey, { [this.config.protocol]: template }, this.snarkjsLogger);
        const contractPath = this.path(circuit, 'sol');
        (0, fs_1.writeFileSync)(contractPath, contractCode);
        return contractPath;
    }
    /** Export calldata to call a Verifier contract.
     * @returns calldata
     */
    async calldata(circuit, input) {
        // fflonk gives error (tested at snarkjs v0.7.0)
        if (this.config.protocol === 'fflonk') {
            throw new Error('Exporting calldata is not supported for fflonk yet.');
        }
        const [pubs, proof] = (await Promise.all(['pubs', 'proof']
            .map(type => this.pathWithInput(circuit, input, type))
            .map(path => (0, promises_1.readFile)(path, 'utf-8')))).map(content => JSON.parse(content));
        return await snarkjs[this.config.protocol].exportSolidityCallData(proof, pubs);
    }
    /** Instantiate the `main` component.
     *
     * If `circuitConfig` argument is omitted, this function will look for it at `circuits.json`
     * in the working directory, and throw an error if no entry is found for the circuit.
     *
     * When config is read from file, `dir` defaults to `main`, otherwise `dir` defaults to `test`.
     * This is done to make it so that when CLI is used circuits are created under `main`, and when
     * we use Circomkit programmatically (e.g. during testing) circuits are created under `test`
     * unless specified otherwise.
     *
     * @returns path of the created main component
     */
    instantiate(circuit, circuitConfig) {
        if (!circuitConfig) {
            const circuitConfigFile = this.readCircuitConfig(circuit);
            circuitConfig = {
                ...circuitConfigFile,
                dir: circuitConfigFile.dir || 'main',
                version: circuitConfigFile.version || this.config.version,
            };
        }
        // directory to output the file
        const directory = circuitConfig.dir || 'test';
        // add "../" to the filename in include, one for each "/" in directory name
        // if none, the prefix becomes empty string
        const filePrefixMatches = directory.match(/\//g);
        let file = circuitConfig.file;
        if (filePrefixMatches !== null) {
            file = '../'.repeat(filePrefixMatches.length) + file;
        }
        // generate the code for `main` component
        const circuitCode = (0, utils_1.makeCircuit)({
            file: file,
            template: circuitConfig.template,
            version: circuitConfig.version || '2.0.0',
            dir: directory,
            pubs: circuitConfig.pubs || [],
            params: circuitConfig.params || [],
        });
        // check the target directory
        const targetDir = `${this.config.dirCircuits}/${directory}`;
        if (!(0, fs_1.existsSync)(targetDir)) {
            (0, fs_1.mkdirSync)(targetDir, {
                recursive: true,
            });
        }
        // write main component to file
        const targetPath = `${targetDir}/${circuit}.circom`;
        (0, fs_1.writeFileSync)(targetPath, circuitCode);
        return targetPath;
    }
    /** Generate a proof.
     *
     * If `data` is not passed, the input data will be read from `inputs/<circuit>/<input>.json`.
     *
     * @returns path of the directory where public signals and proof are created
     */
    async prove(circuit, input, data) {
        // create WASM if needed
        const wasmPath = this.path(circuit, 'wasm');
        if (!(0, fs_1.existsSync)(wasmPath)) {
            this.log('WASM file does not exist, creating it now...', 'warn');
            await this.compile(circuit);
        }
        // create PKEY if needed
        const pkeyPath = this.path(circuit, 'pkey');
        if (!(0, fs_1.existsSync)(pkeyPath)) {
            this.log('Prover key does not exist, creating it now...', 'warn');
            await this.setup(circuit);
        }
        const jsonInput = data || JSON.parse((0, fs_1.readFileSync)(this.pathWithInput(circuit, input, 'in'), 'utf-8'));
        const { proof, publicSignals } = await snarkjs[this.config.protocol].fullProve(jsonInput, wasmPath, pkeyPath, this.snarkjsLogger);
        const dir = this.pathWithInput(circuit, input, 'dir');
        (0, fs_1.mkdirSync)(dir, { recursive: true });
        await Promise.all([
            (0, promises_1.writeFile)(this.pathWithInput(circuit, input, 'pubs'), (0, utils_2.prettyStringify)(publicSignals)),
            (0, promises_1.writeFile)(this.pathWithInput(circuit, input, 'proof'), (0, utils_2.prettyStringify)(proof)),
        ]);
        return dir;
    }
    /** Commence a circuit-specific setup.
     *
     * If `ptauPath` argument is omitted, this function will try to automatically download it.
     * See the {@link ptau} method for more information about this.
     *
     * @returns path of the verifier key and prover key
     */
    async setup(circuit, ptauPath) {
        const r1csPath = this.path(circuit, 'r1cs');
        const pkeyPath = this.path(circuit, 'pkey');
        const vkeyPath = this.path(circuit, 'vkey');
        // create R1CS if needed
        if (!(0, fs_1.existsSync)(r1csPath)) {
            this.log('R1CS does not exist, creating it now...', 'warn');
            await this.compile(circuit);
        }
        // get ptau path
        this.log('Checking for PTAU file...', 'debug');
        if (ptauPath === undefined) {
            // if no ptau is given, we can download it
            if (this.config.prime !== 'bn128') {
                throw new Error('Please provide PTAU file when using a prime field other than bn128');
            }
            ptauPath = await this.ptau(circuit);
        }
        else if (!(0, fs_1.existsSync)(ptauPath)) {
            // if the provided path does not exist, we can download it anyways
            this.log('PTAU path was given but no PTAU exists there, downloading it anyways.', 'warn');
            ptauPath = await this.ptau(circuit);
        }
        // circuit specific setup
        this.log('Beginning setup phase!', 'info');
        if (this.config.protocol === 'groth16') {
            // Groth16 needs a circuit specific setup
            // generate genesis zKey
            let curZkey = this.pathZkey(circuit, 0);
            await snarkjs.zKey.newZKey(r1csPath, ptauPath, curZkey, this.snarkjsLogger);
            // make contributions
            for (let contrib = 1; contrib <= this.config.groth16numContributions; contrib++) {
                const nextZkey = this.pathZkey(circuit, contrib);
                // entropy, if user wants to prompt give undefined
                this.log(`Making contribution: ${contrib}`, 'info');
                await snarkjs.zKey.contribute(curZkey, nextZkey, `${circuit}_${contrib}`, this.config.groth16askForEntropy ? undefined : (0, crypto_1.randomBytes)(32), // entropy
                this.snarkjsLogger);
                // remove current key, and move on to next one
                (0, fs_1.rmSync)(curZkey);
                curZkey = nextZkey;
            }
            // finally, rename the resulting key to pkey
            (0, fs_1.renameSync)(curZkey, pkeyPath);
        }
        else {
            // PLONK or FFLONK don't need specific setup
            await snarkjs[this.config.protocol].setup(r1csPath, ptauPath, pkeyPath, this.snarkjsLogger);
        }
        // export verification key
        const vkey = await snarkjs.zKey.exportVerificationKey(pkeyPath, this.snarkjsLogger);
        (0, fs_1.writeFileSync)(vkeyPath, (0, utils_2.prettyStringify)(vkey));
        return { verifierKeyPath: vkeyPath, proverKeyPath: pkeyPath };
    }
    /** Verify a proof for some public signals.
     * @returns `true` if verification is successful, `false` otherwise.
     */
    async verify(circuit, input) {
        const [vkey, pubs, proof] = (await Promise.all([
            this.path(circuit, 'vkey'),
            this.pathWithInput(circuit, input, 'pubs'),
            this.pathWithInput(circuit, input, 'proof'),
        ].map(path => (0, promises_1.readFile)(path, 'utf-8')))).map(content => JSON.parse(content));
        return await snarkjs[this.config.protocol].verify(vkey, pubs, proof, this.snarkjsLogger);
    }
    /** Calculates the witness for the given circuit and input.
     *
     * If `data` is not passed, the input data will be read from `inputs/<circuit>/<input>.json`.
     *
     * @returns path of the created witness
     */
    async witness(circuit, input, data) {
        const wasmPath = this.path(circuit, 'wasm');
        const wtnsPath = this.pathWithInput(circuit, input, 'wtns');
        const outDir = this.pathWithInput(circuit, input, 'dir');
        const jsonInput = data || JSON.parse((0, fs_1.readFileSync)(this.pathWithInput(circuit, input, 'in'), 'utf-8'));
        (0, fs_1.mkdirSync)(outDir, { recursive: true });
        await snarkjs.wtns.calculate(jsonInput, wasmPath, wtnsPath);
        return wtnsPath;
    }
    /** Exports a JSON input file for some circuit with the given object.
     *
     * This is useful for testing real circuits, or creating an input programmatically.
     * Overwrites an existing input.
     *
     * @returns path of the created input file
     */
    input(circuit, input, data) {
        const inputPath = this.pathWithInput(circuit, input, 'in');
        if ((0, fs_1.existsSync)(inputPath)) {
            this.log('Input file exists already, overwriting it.', 'warn');
        }
        (0, fs_1.writeFileSync)(inputPath, (0, utils_2.prettyStringify)(data));
        return inputPath;
    }
    /** Export a circuit artifact in JSON format.
     *
     * Returns the JSON object itself, and the path that it would be exported to with
     * respect to the Circomkit configuration.
     *
     * @returns a JSON object or the path that it would be exported to.
     */
    async json(type, circuit, input) {
        let json;
        let path;
        switch (type) {
            // R1CS
            case 'r1cs': {
                path = this.path(circuit, 'r1cs');
                json = await snarkjs.r1cs.exportJson(path, undefined); // internal log didnt make sense
                break;
            }
            // Prover key
            case 'zkey': {
                // must be groth16, others give error (tested at snarkjs v0.7.0)
                if (this.config.protocol !== 'groth16') {
                    throw new Error('Exporting zKey to JSON is only supported for Groth16 at the moment.');
                }
                path = this.path(circuit, 'pkey');
                json = await snarkjs.zKey.exportJson(path);
                break;
            }
            // Witness
            case 'wtns': {
                if (!input)
                    throw new Error('Expected input');
                path = this.pathWithInput(circuit, input, 'wtns');
                json = await snarkjs.wtns.exportJson(path);
                break;
            }
            default:
                throw new Error('Unknown export target: ' + type);
        }
        return {
            json,
            path: path + '.json',
        };
    }
    /** Compiles the circuit and returns a witness tester instance. */
    async WitnessTester(circuit, circuitConfig) {
        circuitConfig.dir || (circuitConfig.dir = 'test'); // defaults to test directory
        const targetPath = this.instantiate(circuit, circuitConfig);
        const circomWasmTester = await wasm_tester(targetPath, {
            output: undefined, // this makes tests to be created under /tmp
            prime: this.config.prime,
            verbose: this.config.verbose,
            O: Math.min(this.config.optimization, 1), // tester doesnt have O2
            json: false,
            include: this.config.include,
            wasm: true,
            sym: true,
            recompile: circuitConfig.recompile ?? true,
        });
        return new testers_1.WitnessTester(circomWasmTester);
    }
    /** Returns a proof tester. */
    async ProofTester(circuit) {
        const wasmPath = this.path(circuit, 'wasm');
        const pkeyPath = this.path(circuit, 'pkey');
        const vkeyPath = this.path(circuit, 'vkey');
        // check if all files are present
        const missingPaths = [wasmPath, pkeyPath, vkeyPath].filter(p => !(0, fs_1.existsSync)(p));
        if (missingPaths.length !== 0) {
            throw new Error('Missing files: ' + missingPaths.join(', '));
        }
        return new testers_1.ProofTester(wasmPath, pkeyPath, vkeyPath);
    }
}
exports.Circomkit = Circomkit;
//# sourceMappingURL=circomkit.js.map